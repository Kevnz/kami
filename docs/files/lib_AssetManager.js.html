<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/AssetManager.js - kami</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="kami"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AbstractBatch.html">AbstractBatch</a></li>
            
                <li><a href="../classes/AssetManager.html">AssetManager</a></li>
            
                <li><a href="../classes/AssetManager.ImageLoader.html">AssetManager.ImageLoader</a></li>
            
                <li><a href="../classes/Point.html">Point</a></li>
            
                <li><a href="../classes/SpriteBatch.html">SpriteBatch</a></li>
            
                <li><a href="../classes/Texture.html">Texture</a></li>
            
                <li><a href="../classes/WebGLContext.html">WebGLContext</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/kami.html">kami</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib/AssetManager.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @module kami
 */

var Class = require(&#x27;jsOOP&#x27;).Class;
var Signal = require(&#x27;signals&#x27;);


/**
 * This is a utility which makes asset loading cleaner
 * and simpler, especially with regard to asynchronous image
 * loading and WebGL context loss.
 *
 *
 * Basic usage looks like this:
 *
 *     //Create an asset manager 
 *     var assets = new AssetManager(context);
 *  
 *     //image types will return a new Texture
 *     var tex0 = assets.load(&quot;img/grass.png&quot;);
 *     var tex1 = assets.load(&quot;img/scene.png&quot;);
 *
 *     ... inside game loop ...
 *
 *         if (assets.update()) {
 *             // all assets are loaded, we can render.
 *         } else {
 *             // not all assets are loaded. we need
 *             // to show our preloader.
 *         }
 *
 * Currently this class only supports image loading,
 * although in the future others could be added for 
 * compressed textures, sprite sheets, and so forth.
 *
 * Creating a new asset manager will listen for context
 * loss events on the given WebGLContext. When this happens,
 * all assets will be invalidated and added to the loading queue.
 * As such, update() will return false until the assets have been
 * re-loaded.
 * 
 * @class  AssetManager
 * @constructor 	
 * @param {WebGLContext} context the WebGLContext for this manager
 */
var AssetManager = new Class({
	
	/**
	 * An array of assets that this AssetManager is handling.
	 * This should not be modified directly.
	 * 
	 * @property assets
	 * @type {Array}
	 */
	assets: null,

	/**
	 * The queue of tasks to load. Each contains
	 * an
	 * {{#crossLink &quot;AssetManager.Descriptor&quot;}}{{/crossLink}}.
	 *
	 * Loading a task will pop it off this list and fire the async
	 * or synchronous process.
	 *
	 * This should not be modified directly.
	 *
	 * @property tasks
	 * @protected
	 * @type {Array}
	 */
	tasks: null,

	//Private stuff... do not touch!

	__loadCount: 0,
	__totalItems: 0,
	__loadCallbackFunc: null,
	__invalidateFunc: null,

	// Signals 
	
	/**
	 * A signal dispatched when loading first begins, 
	 * i.e. when update() is called and the loading queue is the
	 * same size as the total asset list.
	 *
	 * @event loadStarted
	 * @type {Signal}
	 */
	loadStarted: null,

	/**
	 * A signal dispatched when all assets have been loaded
	 * (i.e. their async tasks finished).
	 *
	 * @event loadFinished
	 * @type {Signal}
	 */
	loadFinished: null,

	/**
	 * A signal dispatched on progress updates, once an asset
	 * has been loaded in full (i.e. its async task finished).
	 *
	 * This passes three arguments to the listener function:
	 * 
	 * - &#x60;current&#x60; number of assets that have been loaded
	 * - &#x60;total&#x60; number of assets to loaded
	 * - &#x60;name&#x60; of the asset which was just loaded
	 *  
	 * @event loadProgress
	 * @type {[type]}
	 */
	loadProgress: null,

	/**
	 * A signal dispatched on problematic load; e.g. if
	 * the image was not found and &quot;onerror&quot; was triggered. 
	 * The first argument passed to the listener will be 
	 * the string name of the asset.
	 *
	 * The asset manager will continue loading subsequent assets.
	 *
	 * This is dispatched after the status of the asset is
	 * set to Status.LOAD_FAIL, and before the loadProgress
	 * signal is dispatched.
	 *
	 * @event loadError
	 * @type {Signal}
	 */
	loadError: null,

	/**
	 * A read-only property that describes the number of 
	 * assets remaining to be loaded.
	 *
	 * @attribute remaining
	 * @type {Number}
	 * @readOnly
	 */
	remaining: {
		get: function() {
			return this.__totalItems - this.__loadCount;
		}
	},

	/**
	 * A read-only property that descriibes the total
	 * number of assets in this AssetManager.
	 *
	 * @attribute total
	 * @readOnly
	 * @type {Number}
	 */
	total: {
		get: function() {
			return this.__totalItems;
		}
	},

	//Constructor
	initialize: function(context) {
		if (!context)
			throw &quot;no context defined for AssetManager&quot;;

		this.assets = [];
		this.loaders = {};
		this.tasks = [];
		this.__loadCount = this.__totalItems = 0;

		this.loadStarted = new Signal();
		this.loadFinished = new Signal();
		this.loadProgress = new Signal();

		this.__invalidateFunc = this.invalidate.bind(this);
		this.__loadCallbackFunc = this.__loadCallback.bind(this);

		this.context = context;
		this.context.lost.add(this.__invalidateFunc);
	},

	/**
	 * Destroys this asset manager; removing its listeners
	 * with WebGLContext and deleting the assets array.
	 *
	 * @method  destroy
	 */
	destroy: function() {
		this.assets = [];
		this.tasks = [];
		this.__loadCount = this.__totalItems = 0;
		this.context.lost.remove(this.__invalidateFunc);
	},

	/**
	 * Called to invalidate the asset manager
	 * and require all assets to be re-loaded.
	 * This is called internally on context loss.
	 *
	 * @protected
	 * @method invalidate
	 */
	invalidate: function() {
		//mark all as not yet loaded
		for (var i=0; i&lt;this.assets.length; i++) 
			this.assets[i].loaded = false;

		//copy our assets to a queue which can be popped
		this.tasks = this.assets.slice();

		this.__loadCount = this.__totalItems = this.tasks.length;
	},

	/**
	 * Pushes an asset onto this stack. This
	 * attempts to detect the loader for you based
	 * on the asset name&#x27;s file extension. If the
	 * asset name doesn&#x27;t have a known file extension,
	 * or if there is no loader registered for that filename,
	 * this method throws an error. 
	 *
	 * The first argument is the asset name. Any subsequent
	 * arguments will be passed along to the loader for further
	 * processing.
	 *
	 * The return value of this method is determined by
	 * the loader&#x27;s processArguments method. For example, the
	 * default Image loader returns a Texture object.
	 *
	 * @method  load
	 * @param  {String} name the asset name
	 * @param {any} args a variable number of optional arguments
	 * @return {any} returns the best type for this asset&#x27;s loader
	 */
	load: function(name) {
		var ext = this.__extension(name);
		if (!ext) 
			throw &quot;Asset name does not have a file extension: &quot; + name;
		if (!AssetManager.loaders.hasOwnProperty(ext))
			throw &quot;No known loader for extension &quot;+ext+&quot; in asset &quot;+name;

		var args = [ name, AssetManager.loaders[ext] ];
		args = args.concat( Array.prototype.slice.call(arguments, 1) );

		return this.loadAs.apply(this, args);
	},

	__extension: function(str) {
		var idx = str.lastIndexOf(&#x27;.&#x27;);
		if (idx === -1 || idx === 0 || idx === str.length-1) // does not have a clear file extension
			return &quot;&quot;;
		return str.substring(idx+1).toLowerCase();
	},

	/**
	 * Pushes an asset onto this stack. This allows you to
	 * specify a loader function for the asset. This is useful
	 * if you wish to use generic names for your assets (instead of
	 * filenames), or if you want a particular asset to use a specific
	 * loader. 
	 *
	 * Like with {{#crossLink &quot;AssetManager/load:method&quot;}}{{/crossLink}},
	 * the first argument is the asset name. The second argument is the loader
	 * to use for this asset. Any subsequent
	 * arguments will be passed along to the loader for further
	 * processing.
	 *
	 * The return value of this method is determined by
	 * the loader&#x27;s processArguments method. For example, the
	 * default Image loader returns a Texture object.
	 *
	 * @method  load
	 * @param {String} name the asset name
	 * @param {Fucntion} loader the loader function
	 * @param {Object ...} args a variable number of optional arguments
	 * @return {any} returns the best type for this asset&#x27;s loader
	 */
	loadAs: function(name, loader) {
		if (!name)
			throw &quot;no name specified to load&quot;;
		if (!loader)
			throw &quot;no loader specified for asset &quot;+name;

		var idx = this.__indexOf(this.assets, name);
		if (idx !== -1) //TODO: eventually add support for dependencies and shared assets
			throw &quot;asset already defined in asset manager&quot;;

		//grab any additional arguments
		var params = Array.prototype.slice.call(arguments, 2);

		var desc = new AssetManager.Descriptor(name, loader, params);

		//keep hold of this asset
		this.assets.push(desc);

		//also add it to our queue of current tasks
		this.tasks.push(desc);
		this.__loadCount++;
		this.__totalItems++;


		//if we can process the arguments and get a return value...
		if (loader.processArguments) {
			return loader.processArguments.call(this, name, params);
		} else
			return null;
	},

	__indexOf: function(list, name) {
		for (var i=0; i&lt;list.length; i++) {
			if (list[i].name === name)
				return i;
		}
		return -1;
	},

	__loadCallback: function(name, success) {
		if (arguments.length &lt; 2) //some helpful debug information if you&#x27;re writing a Loader
			throw &quot;Loader passed invalid arguments to finished() callback;&quot;
					+&quot; must include name and success flag&quot;;

		this.__loadCount--;

		var assetIdx = this.__indexOf(this.assets, name);
		if (assetIdx !== -1) {
			this.assets[assetIdx].status = success 
						? AssetManager.Status.LOAD_SUCCESS
						: AssetManager.Status.LOAD_FAILED;
			if (!success) {
				this.loadError.dispatch(name);
			}
		}

		this.loadProgress.dispatch( (this.__totalItems - this.__loadCount), 
									this.__totalItems,
									name);
			
		if (this.__loadCount === 0) {
			this.loadFinished.dispatch();
		}
	},

	// TODO....
	// isLoaded: function(name) {
	// 	var assetIdx = this.__indexOf(this.assets, name);
	// 	return assetIdx !== -1 ? this.assets[assetIdx].loaded : false;
	// },

	/**
	 * Updates this AssetManager by loading the next asset in the queue.
	 * If all assets have been loaded, this method returns true, otherwise
	 * it will return false.
	 *
	 * @method  update
	 * @return {Boolean} whether this asset manager has finished loading
	 */
	update: function() {
		if (!this.context.valid)
			return false;

		if (this.tasks.length === 0)
			return (this.__loadCount === 0);

		//If we still haven&#x27;t popped any from the assets list...
		if (this.tasks.length === this.assets.length) {
			this.loadStarted.dispatch();
		}

		//grab the next task on the stack
		var nextTask = this.tasks.shift();

		//apply the loading step
		var loader = nextTask.loader;

		var cb = this.__loadCallbackFunc;

		var newParams = [ nextTask.name, cb ].concat(nextTask.params);
		loader.loadAsset.apply(this, newParams);

		return (this.__loadCount === 0);
	}
});

/**
 * A set of loader plugins for this asset manager. These might be as simple
 * as pushing HTML Image objects into a Texture, or more complex like decoding
 * a compressed, mip-mapped, or cube-map texture.
 *
 * This object is a simple hashmap of lower-case extension names to Loader functions.
 * 
 * @property loaders
 * @static
 * @type {Object}
 */
AssetManager.loaders = {};

/**
 * Registers a loader function with the given extension(s).
 * The first parameter is a loader function, and all subsequent
 * parameters are lower-case extensions (without the period) that
 * should be associated with that loader. This will override other
 * loaders by the same extension.
 *
 * By default, the extensions &quot;png&quot;, &quot;jpg&quot;, &quot;jpeg&quot;, and &quot;gif&quot; are
 * registered to {{#crossLink &quot;AssetManager/ImageLoader:attribute&quot;}}{{/crossLink}}.
 * 
 * @method registerLoader
 * @static
 * @param {Function} loaderFunc the loader function
 * @param {String ...} extensions a variable number of strings
 */
AssetManager.registerLoader = function(loaderFunc, extensions) {
	if (arguments.length===0)
		throw &quot;must specify at least one extension for the loader&quot;;
	var exts = Array.prototype.slice.call(arguments, 1);
	for (var i=0; i&lt;exts.length; i++) 
		AssetManager.loaders[ exts[i] ] = loaderFunc;
};

/**
 * A simple wrapper for assets which will be passed along to the loader;
 * this is used internally.
 * 
 * //@class AssetManager.Descriptor
 */
AssetManager.Descriptor = new Class({

	name: null,
	loader: null,
	params: null,
	status: null,

	initialize: function(name, loader, params) {
		this.name = name;
		this.loader = loader;
		this.params = params;
		this.status = AssetManager.Status.QUEUED;
	}
});

//TODO: document this
/**
 * Defines the status of an asset in the manager queue.
 * @type {Object}
 */
AssetManager.Status = {
	QUEUED: 0,
	LOADING: 1,
	LOAD_SUCCESS: 2,
	LOAD_FAIL: 3
};


//TODO: use a base loader class; pull these out into their own files ?

/**
 * This is the default implementation of an image loader plugin for AssetManager.
 * This uses a DOM Image object to upload PNG, GIF and JPG images to a WebGL
 * texture. You will not need to deal with this class directly, unless you want
 * to write your own AssetManager loaders.
 *
 * A &#x60;Loader&#x60; type for AssetManager is simply an object which defines two (static) methods:
 *
 * - &#x60;loadAsset&#x60;: this is the loading function, which handles the asynchronous load.
 * - &#x60;processArguments&#x60;: this is for the user&#x27;s convenience, handling default arguments
 * and giving a meaningful return value. 
 * 
 * @class AssetManager.ImageLoader
 */
AssetManager.ImageLoader = {
	
	/**
	 * This is a &quot;loader function&quot; which handles the asynchronous
	 * loading for an asset. The function must be implemented in a very
	 * strict manner for the asset manager to work correctly.
	 *
	 * The first parameter passed to this function is the name of the
	 * asset being loaded. The second parameter is a callback that must
	 * be invoked after the async task is completed.
	 * Any subsequent parameters are those that came from the inital call
	 * to {{#crossLink &quot;AssetManager/load:method&quot;}}AssetManager.load{{/crossLink}}. 
	 *
	 * Once the synchronous or asynchronous loading task is completed, the
	 * &#x60;finished&#x60; callback must be invoked with two parameters: first, the
	 * &#x60;name&#x60; of the asset as passed to this loader. And second, a boolean indicating
	 * the &#x60;success&#x60; of the load operation. 
	 *
	 * If you don&#x27;t invoke the callback, the asset manager may never finish loading.
	 * 
	 * @method loadAsset
	 * @static
	 * @param  {String} name the name of the asset to load
	 * @param {Function} finished the function to call when async loading is complete
	 * @param {Texture} texture the texture to operate on for this asset
	 * @param {String} path the optional image path to use instead of the &#x60;name&#x60; parameter
	 */
	loadAsset: function(name, finished, texture, path) {
		if (!texture) {
			throw &quot;no texture object specified to the ImageLoader for asset manager&quot;;
		}

		//if path is undefined, use the asset name and 
		//assume its a path.
		path = path || name;

		var img = new Image();

		img.onload = function() {
			img.onerror = img.onabort = null; //clear other listeners
			texture.uploadImage(img);
			finished(name, true);
		};
		img.onerror = function() {
			img.onload = img.onabort = null;
			console.warn(&quot;Error loading image: &quot;+path);
			//We use null data to avoid WebGL errors
			//TODO: handle fail more smoothly, i.e. with a callback
			//TODO: Should this be pure black, or purely transparent?
			texture.uploadData(1, 1); 
			finished(name, false);
		};
		img.onabort = function() {
			img.onload = img.onerror = null;
			console.warn(&quot;Aborted image: &quot;+path);
			//We use null data to avoid WebGL errors
			texture.uploadData(1, 1);
			finished(name, false);
		};

		//setup source
		img.src = path;
	},

	/**
	 * This method is called from 
	 * {{#crossLink &quot;AssetManager/load:method&quot;}}AssetManager.load{{/crossLink}} to
	 * process the arguments and setup any default values. This is also responsible for
	 * determining the appropriate return value for the load function. In the case of
	 * &#x60;ImageLoader&#x60;, we return the Texture that was passed to the load() function, or
	 * a new Texture object if none was given. This way, the user can write code like this:
	 *
	 *       var texture = assetManager.load(&quot;img.png&quot;); //returns new Texture
	 *
	 * The first argument is the name of the asset being processed. The second argument
	 * is an array of arguments that will be passed to the loader function.
	 * 
	 * The method is called bound to the AssetManager, so we can access WebGLContext
	 * with &quot;this.context&quot;.
	 *
	 * @method  processArguments
	 * @static
	 * @param  {String} name the asset name
	 * @param  {Array} params an array of parameters that will be used to load the asset
	 * @return {any} the object the user may expect from the loader, in this case a Texture object
	 */
	processArguments: function(name, params) {
		//the first parameter is a texture... if not specified, we need to assign it a new object
		if (params.length === 0 || !params[0])
			return (params[0] = new Texture(this.context));
		else
			return params[0];
	}
};

	


// Register our default loaders...

AssetManager.registerLoader(AssetManager.ImageLoader, &quot;png&quot;, &quot;gif&quot;, &quot;jpg&quot;, &quot;jpeg&quot;);

module.exports = AssetManager;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
