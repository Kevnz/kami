<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/AssetManager.js - kami</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="kami"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AssetManager.html">AssetManager</a></li>
            
                <li><a href="../classes/AssetManager.ImageLoader.html">AssetManager.ImageLoader</a></li>
            
                <li><a href="../classes/BaseBatch.html">BaseBatch</a></li>
            
                <li><a href="../classes/Mesh.html">Mesh</a></li>
            
                <li><a href="../classes/SpriteBatch.html">SpriteBatch</a></li>
            
                <li><a href="../classes/Texture.html">Texture</a></li>
            
                <li><a href="../classes/WebGLContext.html">WebGLContext</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/kami.html">kami</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib/AssetManager.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @module kami
 */

var Class = require(&#x27;klasse&#x27;);
var Signal = require(&#x27;signals&#x27;);

/**
 * This is a utility which makes asset loading cleaner
 * and simpler, especially with regard to asynchronous image
 * loading and WebGL context loss.
 *
 *
 * Basic usage looks like this:
 *
 *     //Create an asset manager 
 *     var assets = new AssetManager(context);
 *  
 *     //image types will return a new Texture
 *     var tex0 = assets.load(&quot;img/grass.png&quot;);
 *     var tex1 = assets.load(&quot;img/scene.png&quot;);
 *
 *     ... inside game loop ...
 *
 *         if (assets.update()) {
 *             // all assets are loaded, we can render.
 *         } else {
 *             // not all assets are loaded. we need
 *             // to show our preloader.
 *         }
 *
 * Currently this class only supports image loading,
 * although in the future others could be added for 
 * compressed textures, sprite sheets, and so forth.
 *
 * Creating a new asset manager will listen for context
 * loss events on the given WebGLContext. When this happens,
 * all assets will be invalidated and added to the loading queue.
 * As such, update() will return false until the assets have been
 * re-loaded.
 * 
 * @class  AssetManager
 * @constructor 	
 * @param {WebGLContext} context the WebGLContext for this manager
 */
var AssetManager = new Class({
	

	/**
	 * A read-only property that describes the number of 
	 * assets remaining to be loaded.
	 *
	 * @attribute remaining
	 * @type {Number}
	 * @readOnly
	 */
	remaining: {
		get: function() {
			return this.__totalItems - this.__loadCount;
		}
	},

	/**
	 * A read-only property that descriibes the total
	 * number of assets in this AssetManager.
	 *
	 * @attribute total
	 * @readOnly
	 * @type {Number}
	 */
	total: {
		get: function() {
			return this.__totalItems;
		}
	},

	//Constructor
	initialize: function AssetManager(context) {
		if (!context)
			throw &quot;no context defined for AssetManager&quot;;

		/**
		 * An array of assets that this AssetManager is handling.
		 * This should not be modified directly.
		 * 
		 * @property assets
		 * @type {Array}
		 */
		this.assets = [];

		/**
		 * The queue of tasks to load. Each contains
		 * an
		 * {{#crossLink &quot;AssetManager.Descriptor&quot;}}{{/crossLink}}.
		 *
		 * Loading a task will pop it off this list and fire the async
		 * or synchronous process.
		 *
		 * This should not be modified directly.
		 *
		 * @property tasks
		 * @protected
		 * @type {Array}
		 */
		this.tasks = [];

		//Private stuff... do not touch!

		this.__loadCount = 0;
		this.__totalItems = 0;
		this.__invalidateFunc = null;

		// Signals 
		
		/**
		 * A signal dispatched when loading first begins, 
		 * i.e. when update() is called and the loading queue is the
		 * same size as the total asset list.
		 *
		 * @event loadStarted
		 * @type {Signal}
		 */
		this.loadStarted = new Signal();

		/**
		 * A signal dispatched when all assets have been loaded
		 * (i.e. their async tasks finished).
		 *
		 * @event loadFinished
		 * @type {Signal}
		 */
		this.loadFinished = new Signal();

		/**
		 * A signal dispatched on progress updates, once an asset
		 * has been loaded in full (i.e. its async task finished).
		 *
		 * This passes three arguments to the listener function:
		 * 
		 * - &#x60;current&#x60; number of assets that have been loaded
		 * - &#x60;total&#x60; number of assets to loaded
		 * - &#x60;name&#x60; of the asset which was just loaded
		 *  
		 * @event loadProgress
		 * @type {[type]}
		 */
		this.loadProgress = new Signal();

		/**
		 * A signal dispatched on problematic load; e.g. if
		 * the image was not found and &quot;onerror&quot; was triggered. 
		 * The first argument passed to the listener will be 
		 * the string name of the asset.
		 *
		 * The asset manager will continue loading subsequent assets.
		 *
		 * This is dispatched after the status of the asset is
		 * set to Status.LOAD_FAIL, and before the loadProgress
		 * signal is dispatched.
		 *
		 * @event loadError
		 * @type {Signal}
		 */
		this.loadError = new Signal();

		this.loaders = {};

		this.__invalidateFunc = this.invalidate.bind(this);

		this.context = context;
		this.context.lost.add(this.__invalidateFunc);
	},

	/**
	 * Destroys this asset manager; removing its listeners
	 * with WebGLContext and deleting the assets array.
	 *
	 * @method  destroy
	 */
	destroy: function() {
		this.assets = [];
		this.tasks = [];
		this.__loadCount = this.__totalItems = 0;
		this.context.lost.remove(this.__invalidateFunc);
	},

	/**
	 * Called to invalidate the asset manager
	 * and require all assets to be re-loaded.
	 * This is called internally on context loss.
	 *
	 * @protected
	 * @method invalidate
	 */
	invalidate: function() {
		//mark all as not yet loaded
		for (var i=0; i&lt;this.assets.length; i++) 
			this.assets[i].status = AssetManager.Status.QUEUED;

		//copy our assets to a queue which can be popped
		this.tasks = this.assets.slice();

		this.__loadCount = this.__totalItems = this.tasks.length;
	},


	/**
	 * Attempts to extract a mime-type from the given data URI. It will
	 * default to &quot;text/plain&quot; if the string is a data URI with no specified
	 * mime-type. If the string does not begin with &quot;data:&quot;, this method 
	 * returns null.
	 *
	 * @method  __getDataType
	 * @private
	 * @param  {String} str the data URI
	 * @return {String}     the mime type
	 */
	__getDataType: function(str) {
		var test = &quot;data:&quot;;
		//starts with &#x27;data:&#x27;
		var start = str.slice(0, test.length).toLowerCase();
		if (start == test) {
			var data = str.slice(test.length);
			
			var sepIdx = data.indexOf(&#x27;,&#x27;);
			if (sepIdx === -1) //malformed data URI scheme
				return null;

			//e.g. &quot;image/gif;base64&quot; =&gt; &quot;image/gif&quot;
			var info = data.slice(0, sepIdx).split(&#x27;;&#x27;)[0];

			//We might need to handle some special cases here...
			//standardize text/plain to &quot;txt&quot; file extension
			if (!info || info.toLowerCase() == &quot;text/plain&quot;)
				return &quot;txt&quot;

			//User specified mime type, try splitting it by &#x27;/&#x27;
			return info.split(&#x27;/&#x27;).pop().toLowerCase();
		}
		return null;
	},

	__extension: function(str) {
		var idx = str.lastIndexOf(&#x27;.&#x27;);
		if (idx === -1 || idx === 0 || idx === str.length-1) // does not have a clear file extension
			return &quot;&quot;;
		return str.substring(idx+1).toLowerCase();
	},

	/**
	 * Pushes an asset onto this stack. This
	 * attempts to detect the loader for you based
	 * on the asset name&#x27;s file extension (or data URI scheme). 
	 * If the asset name doesn&#x27;t have a known file extension,
	 * or if there is no loader registered for that filename,
	 * this method throws an error. If you&#x27;re trying to use 
	 * generic keys for asset names, use the loadAs method and
	 * specify a loader plugin.
	 * 
	 * This method&#x27;s arguments are passed to the constructor
	 * of the loader function. 
	 *
	 * The return value of this method is determined by
	 * the loader&#x27;s processArguments method. For example, the
	 * default Image loader returns a Texture object.
	 *
	 * @example
	 *    //uses ImageLoader to get a new Texture
	 *    var tex = assets.load(&quot;tex0.png&quot;); 
	 *
	 *    //or you can specify your own texture
	 *    assets.load(&quot;tex1.png&quot;, tex1);
	 *
	 *    //the ImageLoader also accepts a path override, 
	 *    //but the asset key is still &quot;frames0.png&quot;
	 *    assets.load(&quot;frame0.png&quot;, tex1, &quot;path/to/frame1.png&quot;);
	 *    
	 * @method  load
	 * @param  {String} name the asset name
	 * @param  {any} args a variable number of optional arguments
	 * @return {any} returns the best type for this asset&#x27;s loader
	 */
	load: function(name) {
		if (!name)
			throw &quot;No asset name specified for load()&quot;;

		var ext = this.__getDataType(name);
		if (ext === null)
			ext = this.__extension(name);

		if (!ext) 
			throw &quot;Asset name does not have a file extension: &quot; + name;
		if (!AssetManager.loaders.hasOwnProperty(ext))
			throw &quot;No known loader for extension &quot;+ext+&quot; in asset &quot;+name;

		var args = [ AssetManager.loaders[ext], name ];
		args = args.concat( Array.prototype.slice.call(arguments, 1) );

		return this.loadAs.apply(this, args);
	},

	/**
	 * Pushes an asset onto this stack. This allows you to
	 * specify a loader function for the asset. This is useful
	 * if you wish to use generic names for your assets (instead of
	 * filenames), or if you want a particular asset to use a specific
	 * loader. 
	 *
	 * The first argument is the loader function, and the second is the asset
	 * name. Like with {{#crossLink &quot;AssetManager/load:method&quot;}}{{/crossLink}}, 
	 * any subsequent arguments will be passed along to the loader.
	 *
	 * The return value of this method is determined by
	 * the loader&#x27;s getReturnValue() method, if it has one. For example, the
	 * default ImageLoader returns a Texture object. If the loader function
	 * does not implement this method, &#x60;undefined&#x60; is returned.
	 *
	 * @method  load
	 * @param {Fucntion} loader the loader function
	 * @param {String} name the asset name
	 * @param {Object ...} args a variable number of optional arguments
	 * @return {any} returns the best type for this asset&#x27;s loader
	 */
	loadAs: function(loader, name) {
		if (!name)
			throw &quot;no name specified to load&quot;;
		if (!loader)
			throw &quot;no loader specified for asset &quot;+name;

		var idx = this.__indexOf(this.assets, name);
		if (idx !== -1) //TODO: eventually add support for dependencies and shared assets
			throw &quot;asset already defined in asset manager&quot;;

		//grab the arguments, except for the loader function.
		var args = Array.prototype.slice.call(arguments, 1);

		//now we need to create a new Loader object
		//we apply the constructor with the args (context, name, [varargs...])
		var loaderObj = new ( Function.prototype.bind.apply(loader, 
									[null, this.context].concat(args)) );


		//keep hold of this asset and its original name
		var descriptor = new AssetManager.Descriptor(name, loaderObj);
		this.assets.push( descriptor );

		//also add it to our queue of current tasks
		this.tasks.push( descriptor );
		this.__loadCount++;
		this.__totalItems++;

		//try to get a nice return value from the Loader class
		if (typeof loaderObj.getReturnValue === &quot;function&quot;)
			return loaderObj.getReturnValue();
		else 
			return undefined;
	},

	__indexOf: function(list, name) {
		for (var i=0; i&lt;list.length; i++) {
			if (list[i].name === name)
				return i;
		}
		return -1;
	},

	__loadCallback: function(name, success) {
		//if &#x27;false&#x27; was passed, use it.
		//otherwise treat as &#x27;true&#x27;
		success = success !== false;

		this.__loadCount--;

		var assetIdx = this.__indexOf(this.assets, name);
		if (assetIdx !== -1) {
			this.assets[assetIdx].status = success 
						? AssetManager.Status.LOAD_SUCCESS
						: AssetManager.Status.LOAD_FAILED;
			if (!success) {
				this.loadError.dispatch(name);
			}
		}

		this.loadProgress.dispatch( (this.__totalItems - this.__loadCount), 
									this.__totalItems,
									name);
			
		if (this.__loadCount === 0) {
			this.loadFinished.dispatch();
		}
	},

	// TODO.... getStatus and isLoaded
	// isLoaded: function(name) {
	// 	
	// },

	/**
	 * Updates this AssetManager by loading the next asset in the queue.
	 * If all assets have been loaded, this method returns true, otherwise
	 * it will return false.
	 *
	 * @method  update
	 * @return {Boolean} whether this asset manager has finished loading
	 */
	update: function() {
		if (!this.context.valid)
			return false;

		if (this.tasks.length === 0)
			return (this.__loadCount === 0);

		//If we still haven&#x27;t popped any from the assets list...
		if (this.tasks.length === this.assets.length) {
			this.loadStarted.dispatch();
		}

		//grab the next task on the stack
		var nextTask = this.tasks.shift();

		//apply the loading step
		var loader = nextTask.loader;

		var cb = this.__loadCallback.bind(this, nextTask.name);

		// var newParams = [ nextTask.name, cb ].concat(nextTask.params);
		loader.load.call(loader, cb);

		return (this.__loadCount === 0);
	}
});

/**
 * A set of loader plugins for this asset manager. These might be as simple
 * as pushing HTML Image objects into a Texture, or more complex like decoding
 * a compressed, mip-mapped, or cube-map texture.
 *
 * This object is a simple hashmap of lower-case extension names to Loader functions.
 * 
 * @property loaders
 * @static
 * @type {Object}
 */
AssetManager.loaders = {};

/**
 * Registers a loader function with the given extension(s).
 * The first parameter is a loader function. The second is an array
 * of lower-case extensions (without the period) that
 * should be associated with that loader. This will override other
 * loaders by the same extension. 
 *
 * You can also provide an optional mediaType to support data URI schemes.
 * For example, if the mediaType is specified as &quot;image&quot;, and the extensions
 * are [&quot;png&quot;, &quot;gif&quot;], then in addition to those extensions being associated with
 * the loader, the mime-types &quot;image/png&quot; and &quot;image/gif&quot; will also be supported.
 *
 * By default, the extensions &quot;png&quot;, &quot;jpg&quot;, &quot;jpeg&quot;, and &quot;gif&quot; and their associated
 * media types are
 * registered to {{#crossLink &quot;AssetManager/ImageLoader:attribute&quot;}}{{/crossLink}}.
 * 
 * @method registerLoader
 * @static
 * @param {Function} loaderFunc the loader function
 * @param {Array} extensions array of extension strings, not including period
 * @param {String} mediaType an optional media type 
 */
AssetManager.registerLoader = function(loaderFunc, extensions, mediaType) {
	if (arguments.length===0)
		throw &quot;must specify at least one extension for the loader&quot;;
	
	for (var i=0; i&lt;extensions.length; i++) {
		AssetManager.loaders[ extensions[i] ] = loaderFunc;
		if (mediaType) 
			AssetManager.loaders[ mediaType + &#x27;/&#x27; + extensions[i] ] = loaderFunc;
	}
};


/**
 * A simple wrapper for assets which will be passed along to the loader;
 * this is used internally.
 * 
 * //@class AssetManager.Descriptor
 */
AssetManager.Descriptor = function(name, loader) {
	this.name = name;
	this.loader = loader;
	this.status = AssetManager.Status.QUEUED;
};

//TODO: document this
/**
 * Defines the status of an asset in the manager queue.
 * @type {Object}
 */
AssetManager.Status = {
	QUEUED: 0,
	LOADING: 1,
	LOAD_SUCCESS: 2,
	LOAD_FAIL: 3
};


//TODO: use a base loader class; pull these out into their own files ?

/**
 * This is the default implementation of an image loader plugin for AssetManager.
 * This uses a DOM Image object to upload PNG, GIF and JPG images to a WebGL
 * texture. You will not need to deal with this class directly, unless you want
 * to write your own AssetManager loaders.
 *
 * A Loader plugin is a class which handles the asynchronous loading and provides
 * a convenient return value for the &#x60;AssetManager.load()&#x60; functions. The loader class
 * is constructed with the following parameters: first, the WebGLContext this AssetManager
 * is using, and second, the name of the asset to be loaded. The subsequent arguments are
 * those that were passed as extra to the &#x60;AssetManager.load()&#x60; functions.
 *
 * A loader must implement a &#x60;load()&#x60; function, and it&#x27;s encouraged to also implement a 
 * &#x60;getReturnValue()&#x60; function, for convenience.
 * 
 * @class AssetManager.ImageLoader
 * @constructor 
 * @param {WebGLContext} context the context, passed by AssetManager
 * @param {String} name the unique key for this asset
 * @param {String} path the optional path or data URI to use, will default to the name param
 * @param {Texture} texture an optional texture to act on; if undefined, a new texture
 *                          will be created
 */
AssetManager.ImageLoader = new Class({

	initialize: function ImageLoader(context, name, texture, path) {
		this.name = name;
		this.path = path || this.name;
		this.texture = texture || new Texture(context);
	},

	/**
	 * This is the loading function of a AssetManager plugin, 
	 * which handles the asynchronous loading for an asset. 
	 * The function must be implemented in a very
	 * strict manner for the asset manager to work correctly.
	 *
	 * Once the async loading is done, you must call the &#x60;finished&#x60; callback
	 * that was passed to this method. You can pass the parameter &#x60;false&#x60; to the
	 * finished callback to indicate the async load has failed. Otherwise, it is assumed
	 * to be successful.
	 * 
	 * If you don&#x27;t invoke the callback, the asset manager may never finish loading.
	 * 
	 * @method load
	 * @static
	 * @param  {String} name the name of the asset to load
	 * @param {Function} finished the function to call when async loading is complete
	 * @param {Texture} texture the texture to operate on for this asset
	 * @param {String} path the optional image path to use instead of the &#x60;name&#x60; parameter
	 */
	load: function(finished) {

		var img = new Image();

		var self = this;

		img.onload = function() {
			img.onerror = img.onabort = null; //clear other listeners
			self.texture.uploadImage(img);
			finished();
		};
		img.onerror = function() {
			img.onload = img.onabort = null;
			console.warn(&quot;Error loading image: &quot;+self.path);
			//We use null data to avoid WebGL errors
			//TODO: handle fail more smoothly, i.e. with a callback
			//TODO: Should this be pure black, or purely transparent?
			self.texture.uploadData(1, 1); 
			finished(false);
		};
		img.onabort = function() {
			img.onload = img.onerror = null;
			console.warn(&quot;Aborted image: &quot;+self.path);
			//We use null data to avoid WebGL errors
			self.texture.uploadData(1, 1);
			finished(false);
		};
		//setup source
		img.src = this.path;
	},

	getReturnValue: function() {
		return this.texture;
	}
});

// Register our default loaders...

AssetManager.registerLoader(AssetManager.ImageLoader, 
			[&quot;png&quot;, &quot;gif&quot;, &quot;jpg&quot;, &quot;jpeg&quot;], &quot;image&quot;);


module.exports = AssetManager;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
