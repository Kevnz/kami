/**
 * @module kami
 */

var Class = require('klasse');
var Signal = require('signals');

/**
 * This is a utility which makes asset loading cleaner
 * and simpler, especially with regard to asynchronous image
 * loading and WebGL context loss.
 *
 *
 * Basic usage looks like this:
 *
 *     //Create an asset manager 
 *     var assets = new AssetManager(context);
 *  
 *     //image types will return a new Texture
 *     var tex0 = assets.load("img/grass.png");
 *     var tex1 = assets.load("img/scene.png");
 *
 *     ... inside game loop ...
 *
 *         if (assets.update()) {
 *             // all assets are loaded, we can render.
 *         } else {
 *             // not all assets are loaded. we need
 *             // to show our preloader.
 *         }
 *
 * Currently this class only supports image loading,
 * although in the future others could be added for 
 * compressed textures, sprite sheets, and so forth.
 *
 * Creating a new asset manager will listen for context
 * loss events on the given WebGLContext. When this happens,
 * all assets will be invalidated and added to the loading queue.
 * As such, update() will return false until the assets have been
 * re-loaded.
 * 
 * @class  AssetManager
 * @constructor 	
 * @param {WebGLContext} context the WebGLContext for this manager
 */
var AssetManager = new Class({
	

	/**
	 * A read-only property that describes the number of 
	 * assets remaining to be loaded.
	 *
	 * @attribute remaining
	 * @type {Number}
	 * @readOnly
	 */
	remaining: {
		get: function() {
			return this.__totalItems - this.__loadCount;
		}
	},

	/**
	 * A read-only property that descriibes the total
	 * number of assets in this AssetManager.
	 *
	 * @attribute total
	 * @readOnly
	 * @type {Number}
	 */
	total: {
		get: function() {
			return this.__totalItems;
		}
	},

	//Constructor
	initialize: function AssetManager(context) {
		if (!context)
			throw "no context defined for AssetManager";

		/**
		 * An array of assets that this AssetManager is handling.
		 * This should not be modified directly.
		 * 
		 * @property assets
		 * @type {Array}
		 */
		this.assets = [];

		/**
		 * The queue of tasks to load. Each contains
		 * an
		 * {{#crossLink "AssetManager.Descriptor"}}{{/crossLink}}.
		 *
		 * Loading a task will pop it off this list and fire the async
		 * or synchronous process.
		 *
		 * This should not be modified directly.
		 *
		 * @property tasks
		 * @protected
		 * @type {Array}
		 */
		this.tasks = [];

		//Private stuff... do not touch!

		this.__loadCount = 0;
		this.__totalItems = 0;
		this.__loadCallbackFunc = null;
		this.__invalidateFunc = null;

		// Signals 
		
		/**
		 * A signal dispatched when loading first begins, 
		 * i.e. when update() is called and the loading queue is the
		 * same size as the total asset list.
		 *
		 * @event loadStarted
		 * @type {Signal}
		 */
		this.loadStarted = new Signal();

		/**
		 * A signal dispatched when all assets have been loaded
		 * (i.e. their async tasks finished).
		 *
		 * @event loadFinished
		 * @type {Signal}
		 */
		this.loadFinished = new Signal();

		/**
		 * A signal dispatched on progress updates, once an asset
		 * has been loaded in full (i.e. its async task finished).
		 *
		 * This passes three arguments to the listener function:
		 * 
		 * - `current` number of assets that have been loaded
		 * - `total` number of assets to loaded
		 * - `name` of the asset which was just loaded
		 *  
		 * @event loadProgress
		 * @type {[type]}
		 */
		this.loadProgress = new Signal();

		/**
		 * A signal dispatched on problematic load; e.g. if
		 * the image was not found and "onerror" was triggered. 
		 * The first argument passed to the listener will be 
		 * the string name of the asset.
		 *
		 * The asset manager will continue loading subsequent assets.
		 *
		 * This is dispatched after the status of the asset is
		 * set to Status.LOAD_FAIL, and before the loadProgress
		 * signal is dispatched.
		 *
		 * @event loadError
		 * @type {Signal}
		 */
		this.loadError = new Signal();

		this.loaders = {};

		this.__invalidateFunc = this.invalidate.bind(this);
		this.__loadCallbackFunc = this.__loadCallback.bind(this);

		this.context = context;
		this.context.lost.add(this.__invalidateFunc);
	},

	/**
	 * Destroys this asset manager; removing its listeners
	 * with WebGLContext and deleting the assets array.
	 *
	 * @method  destroy
	 */
	destroy: function() {
		this.assets = [];
		this.tasks = [];
		this.__loadCount = this.__totalItems = 0;
		this.context.lost.remove(this.__invalidateFunc);
	},

	/**
	 * Called to invalidate the asset manager
	 * and require all assets to be re-loaded.
	 * This is called internally on context loss.
	 *
	 * @protected
	 * @method invalidate
	 */
	invalidate: function() {
		//mark all as not yet loaded
		for (var i=0; i<this.assets.length; i++) 
			this.assets[i].loaded = false;

		//copy our assets to a queue which can be popped
		this.tasks = this.assets.slice();

		this.__loadCount = this.__totalItems = this.tasks.length;
	},

	/**
	 * Pushes an asset onto this stack. This
	 * attempts to detect the loader for you based
	 * on the asset name's file extension. If the
	 * asset name doesn't have a known file extension,
	 * or if there is no loader registered for that filename,
	 * this method throws an error. 
	 *
	 * The first argument is the asset name. Any subsequent
	 * arguments will be passed along to the loader for further
	 * processing.
	 *
	 * The return value of this method is determined by
	 * the loader's processArguments method. For example, the
	 * default Image loader returns a Texture object.
	 *
	 * @method  load
	 * @param  {String} name the asset name
	 * @param {any} args a variable number of optional arguments
	 * @return {any} returns the best type for this asset's loader
	 */
	load: function(name) {
		var ext = this.__extension(name);
		if (!ext) 
			throw "Asset name does not have a file extension: " + name;
		if (!AssetManager.loaders.hasOwnProperty(ext))
			throw "No known loader for extension "+ext+" in asset "+name;

		var args = [ name, AssetManager.loaders[ext] ];
		args = args.concat( Array.prototype.slice.call(arguments, 1) );

		return this.loadAs.apply(this, args);
	},

	__extension: function(str) {
		var idx = str.lastIndexOf('.');
		if (idx === -1 || idx === 0 || idx === str.length-1) // does not have a clear file extension
			return "";
		return str.substring(idx+1).toLowerCase();
	},

	/**
	 * Pushes an asset onto this stack. This allows you to
	 * specify a loader function for the asset. This is useful
	 * if you wish to use generic names for your assets (instead of
	 * filenames), or if you want a particular asset to use a specific
	 * loader. 
	 *
	 * Like with {{#crossLink "AssetManager/load:method"}}{{/crossLink}},
	 * the first argument is the asset name. The second argument is the loader
	 * to use for this asset. Any subsequent
	 * arguments will be passed along to the loader for further
	 * processing.
	 *
	 * The return value of this method is determined by
	 * the loader's processArguments method. For example, the
	 * default Image loader returns a Texture object.
	 *
	 * @method  load
	 * @param {String} name the asset name
	 * @param {Fucntion} loader the loader function
	 * @param {Object ...} args a variable number of optional arguments
	 * @return {any} returns the best type for this asset's loader
	 */
	loadAs: function(name, loader) {
		if (!name)
			throw "no name specified to load";
		if (!loader)
			throw "no loader specified for asset "+name;

		var idx = this.__indexOf(this.assets, name);
		if (idx !== -1) //TODO: eventually add support for dependencies and shared assets
			throw "asset already defined in asset manager";

		//grab any additional arguments
		var params = Array.prototype.slice.call(arguments, 2);

		var desc = new AssetManager.Descriptor(name, loader, params);

		//keep hold of this asset
		this.assets.push(desc);

		//also add it to our queue of current tasks
		this.tasks.push(desc);
		this.__loadCount++;
		this.__totalItems++;


		//if we can process the arguments and get a return value...
		if (loader.processArguments) {
			return loader.processArguments.call(this, name, params);
		} else
			return null;
	},

	__indexOf: function(list, name) {
		for (var i=0; i<list.length; i++) {
			if (list[i].name === name)
				return i;
		}
		return -1;
	},

	__loadCallback: function(name, success) {
		if (arguments.length < 2) //some helpful debug information if you're writing a Loader
			throw "Loader passed invalid arguments to finished() callback;"
					+" must include name and success flag";

		this.__loadCount--;

		var assetIdx = this.__indexOf(this.assets, name);
		if (assetIdx !== -1) {
			this.assets[assetIdx].status = success 
						? AssetManager.Status.LOAD_SUCCESS
						: AssetManager.Status.LOAD_FAILED;
			if (!success) {
				this.loadError.dispatch(name);
			}
		}

		this.loadProgress.dispatch( (this.__totalItems - this.__loadCount), 
									this.__totalItems,
									name);
			
		if (this.__loadCount === 0) {
			this.loadFinished.dispatch();
		}
	},

	// TODO....
	// isLoaded: function(name) {
	// 	var assetIdx = this.__indexOf(this.assets, name);
	// 	return assetIdx !== -1 ? this.assets[assetIdx].loaded : false;
	// },

	/**
	 * Updates this AssetManager by loading the next asset in the queue.
	 * If all assets have been loaded, this method returns true, otherwise
	 * it will return false.
	 *
	 * @method  update
	 * @return {Boolean} whether this asset manager has finished loading
	 */
	update: function() {
		if (!this.context.valid)
			return false;

		if (this.tasks.length === 0)
			return (this.__loadCount === 0);

		//If we still haven't popped any from the assets list...
		if (this.tasks.length === this.assets.length) {
			this.loadStarted.dispatch();
		}

		//grab the next task on the stack
		var nextTask = this.tasks.shift();

		//apply the loading step
		var loader = nextTask.loader;

		var cb = this.__loadCallbackFunc;

		var newParams = [ nextTask.name, cb ].concat(nextTask.params);
		loader.loadAsset.apply(this, newParams);

		return (this.__loadCount === 0);
	}
});

/**
 * A set of loader plugins for this asset manager. These might be as simple
 * as pushing HTML Image objects into a Texture, or more complex like decoding
 * a compressed, mip-mapped, or cube-map texture.
 *
 * This object is a simple hashmap of lower-case extension names to Loader functions.
 * 
 * @property loaders
 * @static
 * @type {Object}
 */
AssetManager.loaders = {};

/**
 * Registers a loader function with the given extension(s).
 * The first parameter is a loader function, and all subsequent
 * parameters are lower-case extensions (without the period) that
 * should be associated with that loader. This will override other
 * loaders by the same extension.
 *
 * By default, the extensions "png", "jpg", "jpeg", and "gif" are
 * registered to {{#crossLink "AssetManager/ImageLoader:attribute"}}{{/crossLink}}.
 * 
 * @method registerLoader
 * @static
 * @param {Function} loaderFunc the loader function
 * @param {String ...} extensions a variable number of strings
 */
AssetManager.registerLoader = function(loaderFunc, extensions) {
	if (arguments.length===0)
		throw "must specify at least one extension for the loader";
	var exts = Array.prototype.slice.call(arguments, 1);
	for (var i=0; i<exts.length; i++) 
		AssetManager.loaders[ exts[i] ] = loaderFunc;
};

/**
 * A simple wrapper for assets which will be passed along to the loader;
 * this is used internally.
 * 
 * //@class AssetManager.Descriptor
 */
AssetManager.Descriptor = new Class({

	name: null,
	loader: null,
	params: null,
	status: null,

	initialize: function(name, loader, params) {
		this.name = name;
		this.loader = loader;
		this.params = params;
		this.status = AssetManager.Status.QUEUED;
	}
});

//TODO: document this
/**
 * Defines the status of an asset in the manager queue.
 * @type {Object}
 */
AssetManager.Status = {
	QUEUED: 0,
	LOADING: 1,
	LOAD_SUCCESS: 2,
	LOAD_FAIL: 3
};


//TODO: use a base loader class; pull these out into their own files ?

/**
 * This is the default implementation of an image loader plugin for AssetManager.
 * This uses a DOM Image object to upload PNG, GIF and JPG images to a WebGL
 * texture. You will not need to deal with this class directly, unless you want
 * to write your own AssetManager loaders.
 *
 * A `Loader` type for AssetManager is simply an object which defines two methods:
 *
 * - `loadAsset`: this is the loading function, which handles the asynchronous load.
 * - `processArguments`: this is for the user's convenience, handling default arguments
 * and giving a meaningful return value. 
 * 
 * @class AssetManager.ImageLoader
 */
AssetManager.ImageLoader = {
	
	/**
	 * This is a "loader function" which handles the asynchronous
	 * loading for an asset. The function must be implemented in a very
	 * strict manner for the asset manager to work correctly.
	 *
	 * The first parameter passed to this function is the name of the
	 * asset being loaded. The second parameter is a callback that must
	 * be invoked after the async task is completed.
	 * Any subsequent parameters are those that came from the inital call
	 * to {{#crossLink "AssetManager/load:method"}}AssetManager.load{{/crossLink}}. 
	 *
	 * Once the synchronous or asynchronous loading task is completed, the
	 * `finished` callback must be invoked with two parameters: first, the
	 * `name` of the asset as passed to this loader. And second, a boolean indicating
	 * the `success` of the load operation. 
	 *
	 * If you don't invoke the callback, the asset manager may never finish loading.
	 * 
	 * @method loadAsset
	 * @static
	 * @param  {String} name the name of the asset to load
	 * @param {Function} finished the function to call when async loading is complete
	 * @param {Texture} texture the texture to operate on for this asset
	 * @param {String} path the optional image path to use instead of the `name` parameter
	 */
	loadAsset: function(name, finished, texture, path) {
		if (!texture) {
			throw "no texture object specified to the ImageLoader for asset manager";
		}

		//if path is undefined, use the asset name and 
		//assume its a path.
		path = path || name;

		var img = new Image();

		img.onload = function() {
			img.onerror = img.onabort = null; //clear other listeners
			texture.uploadImage(img);
			finished(name, true);
		};
		img.onerror = function() {
			img.onload = img.onabort = null;
			console.warn("Error loading image: "+path);
			//We use null data to avoid WebGL errors
			//TODO: handle fail more smoothly, i.e. with a callback
			//TODO: Should this be pure black, or purely transparent?
			texture.uploadData(1, 1); 
			finished(name, false);
		};
		img.onabort = function() {
			img.onload = img.onerror = null;
			console.warn("Aborted image: "+path);
			//We use null data to avoid WebGL errors
			texture.uploadData(1, 1);
			finished(name, false);
		};

		//setup source
		img.src = path;
	},

	/**
	 * This method is called from 
	 * {{#crossLink "AssetManager/load:method"}}AssetManager.load{{/crossLink}} to
	 * process the arguments and setup any default values. This is also responsible for
	 * determining the appropriate return value for the load function. In the case of
	 * `ImageLoader`, we return the Texture that was passed to the load() function, or
	 * a new Texture object if none was given. This way, the user can write code like this:
	 *
	 *       var texture = assetManager.load("img.png"); //returns new Texture
	 *
	 * The first argument is the name of the asset being processed. The second argument
	 * is an array of arguments that will be passed to the loader function.
	 * 
	 * The method is called bound to the AssetManager, so we can access WebGLContext
	 * with "this.context".
	 *
	 * @method  processArguments
	 * @static
	 * @param  {String} name the asset name
	 * @param  {Array} params an array of parameters that will be used to load the asset
	 * @return {any} the object the user may expect from the loader, in this case a Texture object
	 */
	processArguments: function(name, params) {
		//the first parameter is a texture... if not specified, we need to assign it a new object
		if (params.length === 0 || !params[0])
			return (params[0] = new Texture(this.context));
		else
			return params[0];
	}
};

	


// Register our default loaders...

AssetManager.registerLoader(AssetManager.ImageLoader, "png", "gif", "jpg", "jpeg");

module.exports = AssetManager;
